# Webクライアントアプリケーションにおけるステートマシンと透過的インターフェース

---

# whoami

- **@axross** / Kohei Asai
- Web Application Developer
- 11月にジョイン
- Kaizen Adのフロントエンド面を担当してます

---

# よろしくお願いします

---

# Webクライアントにおける…何？

- 要はFluxとかReactとかの話
- 根本的な考え方とか
- この話に興味を持ってそうな人がいた

---

# Webクライアントアプリケーション？

- 今のWebフロントエンドには2種類ある
    - **Webドキュメント**
        - 主に静的な情報を提供する
    - **Webクライアントアプリケーション**
        - 主にソフトウェアを提供する

---

# Webクライアントアプリケーションの台頭

- あえて「変遷した」とは言わない
- 今もWebドキュメントも存在する (というかWebは本来そういう用途のはず)
- Reactが新しいからjQueryやめよう！とかではないと思う
- とはいえ、書かれるJavaScriptがアプリケーションとしての体裁を保つそれになった

---

# FluxとReactについておさらい

- 必要のない人は寝ててください

---

# Flux

- Facebookがデザインパターンとして提唱した概念
- オブザーバーパターンをベースとした状態遷移管理のやり方
- ViewなどがAction Creatorをコール
- サブスクライブしているStoreが反応し、メッセージ(Action)の内容をもとに自身の管理する状態を更新する

---

# FluxにおけるView

- ViewはStoreをサブスクライブする
- Storeが管理している状態が更新される際に、その変更がディスパッチされる
- 更新後の状態値が流れてくるので、Viewはそれをもとに画面を再描画する

---

# Virtual DOM

- Viewに流れてくる値は、常に更新後状態の完全値になる (差分ではない)
- が、DOMは差分の手続き的な更新を好む
- Virtual DOMという状態値とDOMとの中間表現があれば、中間表現同士で差分を計算して、DOMをどう変更すればいいかという手続き処理を決定できる
    - っていうのを担うのがReact

---

# Flux ♥ React

- つまりFluxはVirtual DOMのような仕組みがないと成立できない
- Reactがあることで、Fluxが適用できる

---

# よく言われること

- 「Redux (Flux)ってステートマシン (有限オートマトン)っぽいよね」
- 「Redux (Flux)はCQRSを強制できるよね」
- (たぶんFluxのことなんだけど、Reduxが有名なので代名詞として用いられる)

---

# 有限オートマトン

> 有限オートマトン（ゆうげん-、英: finite automaton, FA)または有限状態機械（ゆうげんじょうたいきかい、英: finite state machine, FSM）とは、有限個の状態と遷移と動作の組み合わせからなる数学的に抽象化された「ふるまいのモデル」である。
> 
> デジタル回路やプログラムの設計で使われることがあり、ある一連の状態をとったときどのように論理が流れるかを調べることができる。 有限個の「状態」のうち1つの状態をとる。ある時点では1つの状態しかとらず、それをその時点の「現在状態」と呼ぶ。何らかのイベントや条件によってある状態から別の状態へと移行し、それを「遷移」と呼ぶ。 それぞれの現在状態から遷移しうる状態と、遷移のきっかけとなる条件を列挙することで定義される。

---

# FluxのStore

* たしかに

```javascript
// TodoStore#reduce() ... 
switch (action.type) {
  // ...
  // 入力の定義
  case TodoActionTypes.TOGGLE_TODO:
    // 状態遷移先の定義 (state.update()の返値が遷移後の状態)
    return state.update(
      action.id,
      todo => todo.set('complete', !todo.complete),
    );
  // ...
}
// ...
```

[flux/TodoStore.js at master · facebook/flux · GitHub](https://github.com/facebook/flux/blob/master/examples/flux-todomvc/src/data/TodoStore.js#L55)

---

# CQRS

- コマンドクエリ責務分離 (**C**ommand and **Q**uery **R**esponsibility **S**egregation)
- 読み込みと書き込みをインターフェースとして明確に分ける原則
- Command (書き込み) は必ず副作用を持ち、Query (読み込み) は副作用を持たない
- これらを明確に分けることで、プログラムの振る舞いの理解の難しさが軽減される

[メイヤー先生の偉大さとCommand-Query分離 - 檜山正幸のキマイラ飼育記](http://d.hatena.ne.jp/m-hiyama/20101216/1292469108)

---

# FluxにおけるCQRS

- 状態の変更は必ずAction Creatorを通る → Command
- 現在の状態はStoreしか知り得ない → Query
- それぞれの要素に対して逆の操作をすることはできない
- たしかに…？

---

# つまりどういうことだってばよ？

- Fluxは有限オートマトンのように振る舞わせることができる
- FluxによってCQRSが強制される
- ReactがあることによってFluxが実用できる
- つまり、**Fluxというステートマシンと、Reactという透過的ユーザーインターフェースによってアプリケーションを構築する**

---

# そんなことできんの(本当にできてんの)？

- 「FluxとReactだけ」では無理…
- 各々が時間軸を持つ概念を扱うのが難しい
    - 非同期的処理をどうするか
    - アニメーションをどうするか
    - 事実、当時「FluxのどこでAjaxをするか」という問いで界隈が色々アレした

---

# たとえば？

- ユーザーフィードバックをきちんとする親切な物を作る前提
- リストの項目をロード(更新)したい → ローディング中にその旨を表示したい
    - メッセージ(Action)が2つ同時にディスパッチされる必要がある
- Storeの中で例外やエラーが発生したらどうするか？
    - 諦めたい
        - 通常発生しないような例外は諦めてクラッシュさせたい
        - というか、発生しうる例外(通信の失敗など)は、その外側でハンドルした上でStoreに入りたい

---

# じゃあどうするか？

- StoreからActionを呼べば、一応できる
- とはいえ、これはFluxでは禁止されている
    - データフローが単方向であるというメリットを失ってしまう
- Fluxの上にもう一つ、何かを敷く必要がある

---

# Fluxの上に何かを敷く？

- 「ユースケース層」 : ユーザー入力から、Action Creatorを並列・直列に組み合わせてコールする手続き的な層が必要
- redux-saga、redux-thunk、redux-observable
    - Reduxのミドルウェアとして、独自DSLなどでユースケース層を作る
- クリーンアーキテクチャなど
    - 中規模以上であれば、きちんとしたアーキテクチャに乗せるのも良い

---

##

[image:98CADFAF-9467-46CB-B872-1B3BAF09508E-76953-0001634BF0FC9BDD/aaa.png]

---

# その他

- iOSやAndroidでもFluxの活用例が増えてきた
    - とはいえ、iOSやAndroidにVirtual DOMはないので、何らかの仕組みは必要
        - facebook/componentkit
        - zserge/anvil
- というかゲームとかだと、こういうやり方をしているものが多い
- Webフロントエンドも生産性を落とさない設計で開発していきましょう
